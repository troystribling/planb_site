<p>
  While developing the <a href="http://research.inplanb.com/has_ancestor"  target="_blank">has_ancestor</a> plugin, frequently evaulation
  of specs involving arrays of obects was required. Situations arose in <code>should</code> evaluations in which arrays were either on 
  both sides of the evaluation, the right side of the evalutaion or the left side of the evaluation. To solve the problem 
  <code>ArrayMatcher</code> was developed. <code>ArrayMatcher</code> provides an implementation of the 
  <a href="http://rspec.rubyforge.org/rdoc/index.html">RSpec matcher</a> interface that allows specification of a scalar match condition
  when arrays or scalars are specified on either sode of a <code>should</could> condtion in a spec. 
</p>
</p>

</typo:code>
</p>

</p>
<typo:code lang="ruby">

    class ArrayMatcher 
  
      attr_reader :expected_error, :expected, :msg_error, :not_matched, :value
      
      def initialize(expected)
        @expected = expected
        @expected_error = @expected
      end
  
      def matches?(val)          
        @value = val
        @not_matched = Array.new(value.length, true) if @value.class.eql?(Array)
        if @value.class.eql?(Array) and not @expected.class.eql?(Array)
          check_values(@expected, false)
        elsif not @value.class.eql?(Array) and @expected.class.eql?(Array)
          @expected.detect do |e| 
            check_expected(@value, e).eql?(true)
          end.nil? ? false : true              
        elsif @value.class.eql?(Array) and @expected.class.eql?(Array) 
          if @value.length.eql?(@expected.length)
            @expected.detect do |e| 
              check_values(e, true).eql?(false)
            end.nil? ? true : false
          else
            @msg_error = "Expected:\n  array length=#{@expected.length}\n" + "Got:\n  array length=#{@value.length}\n"
            false
          end
        else
          check_expected(@value, @expected)
        end
      end
      
      def check_values(expt, cond)
        match_index = (0..@value.length-1).detect {|i| check_expected(@value[i], expt).eql?(cond) and @not_matched[i]}
        if match_index.nil?
          not cond
        else
          @not_matched[match_index] = false
          cond
        end
      end
      
      def message(msg)
        if @value.class.eql?(Array) and not @expected.class.eql?(Array)
          @value.each {|v| write_expected(msg, @expected, v)}
          @value.each {|v| write_value(msg, @expected, v)}
        elsif not @value.class.eql?(Array) and @expected.class.eql?(Array)
          @expected.each {|e| write_expected(msg, e, @value)}
          @expected.each {|e| write_value(msg, e, @value)}
        elsif @value.class.eql?(Array) and @expected.class.eql?(Array) 
          (0..@expected.length-1).each {|i| write_expected(msg, @expected[i], @value[i])}
          (0..@expected.length-1).each {|i| write_value(msg, @expected[i], @value[i])}
        else
          write_expected(msg, @expected, @value)
          write_value(msg, @expected, @value)
        end
        msg
      end

      def failure_message
        @msg_error.nil? ? message("Match Failure\n") : @msg_error
      end

      def negative_failure_message
        message("Matched\n")
      end

      def description
        "match array of scalars"
      end

      def check_expected(val, expt)
        expt.eql?(val)
      end

      def write_expected(msg, exp, val)
        msg << "Expected:\n"
      end
      
      def write_value(msg, exp, val)
        msg << "Got:\n"
      end
      
    end
  
    def array_matcher(expected)
      ArrayMatcher.new(expected)
    end
   

</typo:code>
</p>

</p>
<typo:code lang="ruby">

    module PlanB
      
      module SpecMatchers    
    
          class HaveAttributesWithValues < PlanB::SpecMatchers::ArrayMatcher #:nodoc:
          
            def description
              "match array of hashes"
            end
    
            def check_expected(val, expt)
              expt.detect{|k, v| not v.eql?(val.attributes[k])}.nil? ? true : false
            end
              
            def write_expected(msg, exp, val)
              super
              exp.each {|k, v| msg <<  " #{k} => #{v}\n"}
            end
            
            def write_value(msg, exp, val)
              super
              exp.each {|k, v| msg <<  " #{k} => #{val.attributes[k]}\n"}
            end
          
          end
        
          def have_attributes_with_values(expected)
            HaveAttributesWithValues.new(expected)
          end
       
      end
    end

</typo:code>
</p>
